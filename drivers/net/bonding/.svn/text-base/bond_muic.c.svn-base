/* Brick bats can be emailed to cchered2@uiuc.edu */

/* Modifications by: Rishi Bhardwaj <rbhardw2 at uiuc dot edu>
 * Changes made:
 * Bug Fix: Incrmenting of timers in bond_xmit_muic() function.
 * The management packets sent by the user process, leaving RREPs,
 * are all broadcast packets. The TOS field for the management 
 * packets is appropriately set. Currently we do not implement TOS
 * dictated QoS at the bonding layer. We currently have a single 
 * packet queue per channel. As a hack we give priority to broadcast
 * packets by inserting them at head of the respective channel queues. 
 * 
 * TODO: Implementation of IP header TOS field dictated QoS. 
 * Similar to the QoS implementation done in madwifi
 */

#include <linux/skbuff.h>
#include <linux/netdevice.h>
#include <linux/etherdevice.h>
#include <linux/pkt_sched.h>
#include <linux/spinlock.h>
#include <linux/slab.h>
#include <linux/timer.h>
#include <linux/ip.h>
#include <linux/ipv6.h>
#include <linux/if_arp.h>
#include <linux/if_ether.h>
#include <linux/if_bonding.h>
#include <linux/if_vlan.h>
#include <linux/netdevice.h>
#include <linux/init.h>
#include <linux/wireless.h>
#include <linux/time.h>
#include <linux/timer.h>
#include <linux/kernel.h>
#include <linux/proc_fs.h>
#include <linux/seq_file.h>
#include <linux/module.h>
#include <net/ipx.h>
#include <net/iw_handler.h>
#include <asm/byteorder.h>
#include <net/dst.h>
#include "bonding.h"
#include "bond_muic.h"

#define dd2printk(fmt, args...) \
	printk(KERN_DEBUG     \
			DRV_NAME ": %s() %d: " fmt, __FUNCTION__, __LINE__ , ## args )	       

#define d2printk(format , args...)  printk(DRV_NAME ": %s(): " format , __FUNCTION__, ## args)
							       
#if 1
#define d2printk(format , args...)
#endif

/****************************** Start defining very important pre processors **********************/

/* All measures in Milli seconds */
#define MUIC_TIME_STEP ((10 * HZ)/ 1000) 	/* 10 Milli seconds */
#define MUIC_TIME_MIN ((20 * HZ)/ 1000) 	/* XXX 20 Milli seconds - at least 2 slice times ???*/
#define MUIC_TIME_MAX ((60 * HZ)/ 1000)		/* 60 Milli seconds */

/*
 * If min switch time is too small (say 10ms = 1 slice). The tx tasklet from madwifi may never run.
 * This may cause many unseen effects. Such as loss at very low load/traffic.
 *
 * When traffic is too high. We should make sure we check to see all packets have been processed.
 * Then we will not risk loosing too many border packets.
 * */

/* XXX Hack: Guessing 5.5 to be the main bit rate for the 11a mode */
#define MEGA 1000000
#define BIT_RATE (5.5 * MEGA)

/* XXX: Seems like I never use this macro, only the FINE version is used */

#define CALC_TRANSMIT_TIME(packet_size)\
	((packet_size * 8 * HZ) / BIT_RATE)
							       
/* Calculations based on 11a. 
 * 
 * 1. Assumed NO RTS/CTS
 * 2. Even for broadcast ACK penality is added
 * 3. Every packet has a 24 us preamble (including ACK)
 * 4. Between data and ack, there is a 16 us SIFS delay
 * 5. ACK is approximately 20 bytes in length.
 * 
 * */ 
#define MY_HZ 1000000
							       
#define ACK_PKT_SZ 20
#define SIFS_LEN (16 * MY_HZ/MEGA)	/* 16 us */
#define PREAMBLE_LEN (24 * MY_HZ/MEGA)	/* 24 us */
							       
#define FINE_CALC_TRANSMIT_TIME(packet_size)\
	((((packet_size + ACK_PKT_SZ) * 8 * MY_HZ) / BIT_RATE) + SIFS_LEN + (PREAMBLE_LEN * 2))

#define COARSE(tx_time) \
	((tx_time * HZ) / MY_HZ)

#define UPDATE_STATS_TIME HZ

/* Done */
							       
/****************************************** MAIN CODE  ******************************************/
							       
/* This function adds to slaves current channel, a certain penality.
 * 
 * Usually when:
 * 1. Channel switches - add switch time penality
 * 2, Channel switch deferred - add deferral penality 
 * 
 * All time units stored are in micro seconds. However, the second arguement
 * passed is in "HZ" units, so scale by a factor of (MY_HZ / HZ) to convert to
 * micro seconds.
 *
 * XXX: Call this function only after the updating slave's  current channel to
 * reflect channel to be penalized.
 */
	       
static inline void 
bond_muic_add_time(struct muic_slave_info *slave, unsigned int time)
{
	unsigned long penality;
	/* Calculate penality in MY_HZ (micro seconds) */
	penality = (time * MY_HZ) / HZ;
	/* Add to total time */
	slave->usage_info[slave->cur_chan_index].cur_usage += penality;
	
	return;
}

/* This function when passed a channel and a packet size, calculates the amount
 * of time it will take to transmit and adds the delay to the channel.
 *
 * Make sure current channel on slave info reflects the actual channel
 *
 * XXX: This call usually appears just before handing the packet to the device
 * layer.
 */

static inline void 
bond_muic_calc_add(struct muic_slave_info *slave, unsigned int pkt_sz)
{
	unsigned long tx_time;
	
	/* Calculate TX time */
	tx_time = FINE_CALC_TRANSMIT_TIME(pkt_sz);
	/* Add to total time */
	slave->usage_info[slave->cur_chan_index].cur_usage += tx_time;
	
	return;
}

/* This is the function called when the stats timer expires every second. The
 * stats timer updates all current usage to zero, and updates usage (using an
 * exponential weightage with the previous one seconds usage).
 *
 * NB: Total time should add to less than 1000 ms.
 *
 * idle time = 1000 ms -  sum (all channel times)
 */

#define RATIO_ALPHA 50
#define RATIO_SUM 100

/* Should you read lock BOND_MUIC INFO at least */

static void
bond_muic_update_stats(unsigned long arg)
{
	struct muic_slave_info *slave = (struct muic_slave_info *) arg;
	unsigned long local_cur_usage;
	int i;

	/* Lock bonding and MUIC */
	read_lock(&slave->bond->lock);
	read_lock(&slave->bond->muic_info.lock);

	for(i=0; i < slave->nchan; i++) {
		local_cur_usage = slave->usage_info[i].cur_usage;
		/* Normalize to one second */
		local_cur_usage = (local_cur_usage * HZ) / UPDATE_STATS_TIME;
		/* Reset current usage */
		slave->usage_info[i].cur_usage = 0;
		
		/* Weighted average - Impleted as interger operations 
		 * usage = usage (alpha) + cur_usage * (1 - alpha) */
		
		slave->usage_info[i].usage = 
			(slave->usage_info[i].usage * (RATIO_ALPHA) + 
			 local_cur_usage * (RATIO_SUM - RATIO_ALPHA)) / RATIO_SUM;
	}

	/* Schedule yourself again in on UPDATE_STATS_TIME */
	
	/* Init, set expire time and add timer */
	init_timer(&slave->stats_timer);
	slave->stats_timer.expires = jiffies + UPDATE_STATS_TIME;
	add_timer(&slave->stats_timer);

	/* Unlock bonding and MUIC */
	read_unlock(&slave->bond->lock);
	read_unlock(&slave->bond->muic_info.lock);

	return;
}

#undef RATIO_ALPHA
#undef RATIO_SUM

/*
 * Return the driver handler associated with a specific Wireless Extension.
 * Called from various place, so make sure it remains efficient.
 */
static inline iw_handler get_handler(struct net_device *dev,
				     unsigned int cmd)
{
	/* Don't "optimise" the following variable, it will crash */
	unsigned int	index;		/* *MUST* be unsigned */

	/* Check if we have some wireless handlers defined */
	if(dev->wireless_handlers == NULL)
		return NULL;

	/* Try as a standard command */
	index = cmd - SIOCIWFIRST;
	if(index < dev->wireless_handlers->num_standard)
		return dev->wireless_handlers->standard[index];

	/* Try as a private command */
	index = cmd - SIOCIWFIRSTPRIV;
	if(index < dev->wireless_handlers->num_private)
		return dev->wireless_handlers->private[index];

	/* Not found */
	return NULL;
}

//XXX: Should do this in a cleaner fashion
//int bond_xmit_broadcast(struct sk_buff *skb, struct net_device *bond_dev);


static void
bond_muic_switch_channel(unsigned long arg)
{
	struct muic_slave_info *slave = (struct muic_slave_info *) arg;
	int start_at = 0, Qindex = -1, ret, i;
	struct sk_buff_head *Q = NULL;
	struct sk_buff *skb = NULL;
	unsigned long tx_time;
	struct iw_freq fr_set;
	struct bonding *bond;
	struct iw_statistics *iw_stats = NULL;
	int res = 1;
	unsigned tx_unproc = 0;

	bond = slave->bond;
	
	read_lock(&bond->lock);
	read_lock(&bond->muic_info.lock);
	if(atomic_read(&slave->chan_switcher_running) == 1)
	{
		printk(KERN_ERR "bonding:bond_muic.c:Rishi:Two instances of muic_switch_channel operational?\n");
		if(atomic_read(&slave->timer_initialized) != 1){
			printk("ERROR, timer_initialized not set on %s and I am the timer :-/\n", slave->dev->name);
		}
		init_timer(&slave->timer);
		slave->timer.expires = jiffies + MUIC_TIME_STEP;
		/* Activate timer */
		add_timer(&slave->timer);
		read_unlock(&bond->muic_info.lock);
		read_unlock(&bond->lock);
		return;
				
	}
	atomic_set(&slave->chan_switcher_running, 1);	/* Main send should do very little now */
	write_lock(&slave->lock);
	
#define LIMIT_DEFER 5

	iw_stats = slave->get_wireless_stats(slave->dev);
	
	if(iw_stats) {
		tx_unproc = iw_stats->discard.fragment;	/* Atheros driver hack, sets this to tx_uproc */
	}
	
	if((tx_unproc > 1 || netif_queue_stopped(slave->dev)) && slave->switch_defer_count < LIMIT_DEFER) {
	
		slave->switch_defer_count++;
		slave->total_deferrals++;
		atomic_set(&slave->switch_deferred, 1);	/* Now we should stop */
		res = 0; 				/* To avoid call to dev_free_skb with NULL pointer */
		/* Re assign timer */
		init_timer(&slave->timer);
		slave->timer.expires = jiffies + MUIC_TIME_STEP;	/* MUIC_TIME_STEP is at 10 ms for now */
		/* Reschedule yourself */
		add_timer(&slave->timer);
		
		/* Add defer penality */
		bond_muic_add_time(slave, MUIC_TIME_STEP);
		goto err;
	}
	
	if(slave->cur_chan_index >= 0 && slave->cur_chan_index < slave->nchan)
		start_at = (slave->cur_chan_index+1) % slave->nchan;
 	
	/* Search circularly */
	for(i = start_at; i < slave->nchan; i++){
		if(!skb_queue_empty(&slave->queues[i])){
			Q = &(slave->queues[i]);
			Qindex = i;
			break;
		}
	}
	
	if(Qindex < 0) {
		for(i=0; i < start_at; i++){
			if(!skb_queue_empty(&slave->queues[i])){
				Q = &(slave->queues[i]);
				Qindex = i;
				break;
			}
		}
	}

	/* Sanity check for Qindex */

	if(Qindex < 0 || Qindex == slave->cur_chan_index || Qindex >= slave->nchan || Q == NULL) {
		printk(KERN_ERR DRV_NAME "Disaster.. should never happen, all Qs empty "
				"(or only 1 Q not empty) and channel switcher started\n");
		goto err;
	}
	
	/* Change to new channel */
	fr_set.m = (__s32) slave->channels[Qindex];
	fr_set.e = 0;
	ret = slave->set_iwfreq(slave->dev, NULL, (union iwreq_data *) &fr_set, NULL);

	/* Unset the deferrals */
	atomic_set(&slave->switch_deferred, 0);
	slave->switch_defer_count = 0;
	
	/* Set cur chan */
	slave->cur_chan = slave->channels[Qindex];
	slave->cur_chan_index = Qindex;

	/* Add switch penality */
#define SWITCH_PENALITY 10 /* Milli seconds */
	/* To convert milli to HZ - (10/1000) * HZ */
	bond_muic_add_time(slave, (SWITCH_PENALITY * 10 / 1000));
	

	/* Increment nof switches */
	slave->switches++;

	/* Compute average tx complete */
	
	/* slave->average_tx_complete = (slave->average_tx_complete * (slave->switches-1) + slave->relative_tx_complete)
							/ slave->switches;
	*/
	/* Make computation an EWMA for now */
	slave->average_tx_complete = (slave->average_tx_complete * 75 + slave->relative_tx_complete * (100 - 75)) / 100;

	/* Weighted average number of packets in channel queue */
#define PERCENTAGE_WEIGHT 50
	slave->avg_qlen[slave->cur_chan_index] = (slave->avg_qlen[slave->cur_chan_index] * PERCENTAGE_WEIGHT +
							skb_queue_len(Q) * (100 - PERCENTAGE_WEIGHT)) / 100;
#undef PERCENTAGE_WEIGHT


	/* Time spent on channel */
	slave->average_time_on_channel = (slave->average_time_on_channel * 75 + (jiffies - slave->last_switch) * (100-75))/100;
	/* Average packets per switch */
	slave->average_packets_per_switch = (slave->average_packets_per_switch * 75 + 
			(slave->total_tx_packets - slave->packets_last_switch) * (100 - 75)) / 100;

	/* Number of packets we sent out per switch per second */
	slave->average_rate = (slave->average_rate * 75 + 
		(((slave->total_tx_packets - slave->packets_last_switch) * HZ) / (jiffies - slave->last_switch)) * (100-75))/100;

	slave->packets_last_switch = slave->total_tx_packets;

	slave->last_switch = jiffies;
	
	/* Start new timing window */
	slave->tx_start = jiffies;
	slave->relative_tx_complete = 0;

	/* Default - exit because Q will become empty, if NOT (ie. exit due to
	 * max time reached), decrement in max time reached IF block */

	slave->exit_q_empty++;

	while(!skb_queue_empty(Q)){
		skb = skb_dequeue(Q);
		if(skb == NULL){
			printk(KERN_ERR DRV_NAME "This should never happen, switcher has skb == NULL\n");
			continue;
			/* goto err; -- skb_queue_empty should take care of the NULL reply */
		}
		tx_time = FINE_CALC_TRANSMIT_TIME(skb->len);
		slave->relative_tx_complete += tx_time;
		slave->total_tx_time += tx_time;
		slave->tx_complete = slave->tx_start + COARSE(slave->relative_tx_complete);
		slave->tx_bytes[Qindex] += skb->len;
		slave->tx_packets[Qindex]++;
		slave->total_tx_packets++;
		slave->total_tx_bytes += skb->len;
		/* Update usage stats */
		bond_muic_calc_add(slave, skb->len);
		res = bond_dev_queue_xmit(slave->bond, skb, slave->dev);	/* slave->dev == rp->out_dev */
		
		/* send it down to the card */
		if(res && skb != NULL) {
			dev_kfree_skb(skb);
			bond->muic_info.dropped++;
		}
		if(slave->tx_complete > (slave->last_switch + bond->muic_info.max_time_jiffies)){
			slave->exit_t_max++;	/* Exit because we reached max time */
			slave->exit_q_empty--;	/* ++++NOT++++ exit because queue is empty (both could be true, but max time is more important) */
			break;
		}
	}

	/* Find if any other Queue is NOT empty and switch to set timer to switch to that channel */
	start_at = Qindex + 1; /* Sideffect if changed, see below */
	Qindex = -1;
	
	/* Search circularly */
	for(i = start_at; i < slave->nchan; i++){
		if(!skb_queue_empty(&slave->queues[i])){
			Qindex = i;
			break;
		}
	}
	if(Qindex < 0) {
		/* (start_at-1) because we don't want to hit Qindex again */
		for(i=0; i < (start_at-1); i++){
			if(!skb_queue_empty(&slave->queues[i])){
				Qindex = i;
				break;
			}
		}
	}

	if(Qindex > -1) {
		if(atomic_read(&slave->timer_initialized) != 1){
			printk("ERROR, timer_initialized not set on %s and I am the timer :-/\n", slave->dev->name);
		}
		init_timer(&slave->timer);
		/* To optimize for unbalanced flows, we should not have a guard band */
		/* slave->timer.expires = slave->tx_complete + MUIC_TIME_STEP;*/ /* Add a guard band */
		/* Check min time on a channel condition */
		if(slave->timer.expires < (slave->last_switch + bond->muic_info.min_time_jiffies)) {
			slave->timer.expires = slave->tx_complete + bond->muic_info.min_time_jiffies;
		}
		/* Activate timer */
		add_timer(&slave->timer);
	} else { /* All Qs empty */
		atomic_set(&slave->timer_initialized, 0);
		/* Drain any remaining packets since no other queue has any packets anyways */
		if(!skb_queue_empty(Q)) {
			Qindex = start_at - 1;	
			while(!skb_queue_empty(Q)){
				skb = skb_dequeue(Q);
				if(skb == NULL){
					printk(KERN_ERR DRV_NAME "This should never happen, switcher has skb == NULL\n");
					continue;
					/* goto err; -- skb_queue_empty should take care of the NULL reply */
				}
				tx_time = FINE_CALC_TRANSMIT_TIME(skb->len);
				slave->relative_tx_complete += tx_time;
				slave->total_tx_time += tx_time;
				slave->tx_complete = slave->tx_start + COARSE(slave->relative_tx_complete);
				slave->tx_bytes[Qindex] += skb->len;
				slave->tx_packets[Qindex]++;
				slave->total_tx_packets++;
				slave->total_tx_bytes += skb->len;
				/* Update usage stats */
				bond_muic_calc_add(slave, skb->len);
				res = bond_dev_queue_xmit(slave->bond, skb, slave->dev);	/* slave->dev == rp->out_dev */
				/* send it down to the card */
				if(res && skb != NULL) {
					dev_kfree_skb(skb);
					bond->muic_info.dropped++;
				}
			}

		}
	}

	/* XXX: Module unloading !!!! */

err:
	if (res) {
		/* no suitable interface, frame not sent */
		dev_kfree_skb(skb);
	}
		
	write_unlock(&slave->lock);
	atomic_set(&slave->chan_switcher_running, 0);	/* Main send should do very little until now */
	
	read_unlock(&bond->muic_info.lock);
	read_unlock(&bond->lock);
	return;
}


// BHs are disabled before the call to the function below.
int bond_xmit_muic(struct sk_buff *skb, struct net_device *bond_dev)
{
	struct bonding *bond = bond_dev->priv;
	struct muic_route_entry *rp = NULL;
	int res = 1, unicast = -1;

	read_lock(&bond->lock);
	read_lock(&bond->muic_info.lock);
	
	if (!BOND_IS_OK(bond)) {
		goto out;
	}

	/* NON IP, ARP perhaps */
	if(skb->dst == NULL) {
		unicast = 0;

	}
	
	/* BROADCAST */
	if(skb->dst != NULL){
		if(skb->dst->hh != NULL){
			if((skb->nh.iph->daddr & 0xff000000) == 0xff000000) {
				unicast = 0;	/* Broadcast */
			}
		}
	}
	
	/* UNICAST */
	if(unicast == -1 && skb->dst != NULL){
		if(skb->dst->hh != NULL){
			for(rp = bond->muic_info.head; rp != NULL; rp = rp->next){
				 if(skb->nh.iph->daddr == rp->dip_addr) {
					unicast = 1;	/* We should unicast the packet */
					break;/* Match found */
				}
			}
			if(unicast != 1) {
				/* If we did not find any route, use the *default* route entry, if it exists */
				for(rp = bond->muic_info.head; rp != NULL; rp = rp->next){
					/* Default route is identified by dst_addr being NULL (0.0.0.0) */
					if(0 == rp->dip_addr) {
						unicast = 1;	/* We should unicast the packet */
						break;/* Match found */
					}
				}
			}
		}
	}
       
	if(unicast == 1) { /* UNICAST */
		struct muic_slave_info *slave = rp->out_slave->muic_sl_info;
		if(slave->cur_chan == rp->dst_chan && 
				atomic_read(&slave->chan_switcher_running) == 0 &&
				atomic_read(&slave->switch_deferred) == 0)	/* Switch deferred == 1 --> Waiting for packets 
										 on current channel to be drained ==> 
										 Don't pump more, just add to queue */
		{

			/* Card on current channel & Channel switcher is NOT running & Channel switcher has not deferred */
			unsigned long tx_time;
			
			
			/* Timer is NOT running, so directly send after locking */
			/* Read lock slave, so switcher won't interfere */
			read_lock(&slave->lock);
			
			if(slave->tx_complete < jiffies){
				slave->tx_start = jiffies;
				slave->relative_tx_complete = 0;
			}
		
			tx_time = FINE_CALC_TRANSMIT_TIME(skb->len);
			slave->total_tx_time += tx_time;
			slave->relative_tx_complete += tx_time;
			slave->tx_complete = slave->tx_start + COARSE(slave->relative_tx_complete);
			
			/* Channel switcher timer is initialized, change mod_timer */
			if(atomic_read(&slave->timer_initialized) == 1) {
				if(slave->tx_complete > slave->timer.expires && 
					(slave->last_switch + bond->muic_info.max_time_jiffies) > slave->tx_complete) {
					/* Increment by step */
					
					/* Bug Fix: Increment the timer to one time step after the tx completes */
					mod_timer(&slave->timer, (slave->tx_complete + MUIC_TIME_STEP));

					
				} 
				else if(slave->tx_complete > slave->timer.expires) { 
					
					/* Bug Fix: Modify timer to expire after tx completes */
					mod_timer(&slave->timer, (slave->tx_complete + MUIC_TIME_STEP));
					
					/* Matches when we already hit max time, and tx_complete is beyong expires time */
					atomic_set(&slave->switch_deferred, 1);	/* Only buffer now */
				}
			}
			slave->tx_packets[rp->chan_index]++;
			slave->tx_bytes[rp->chan_index] += skb->len;
			slave->total_tx_packets++;
			slave->total_tx_bytes += skb->len;
			/* Update usage stats */
			bond_muic_calc_add(slave, skb->len);
			res = bond_dev_queue_xmit(bond, skb, slave->dev);	/* slave->dev == rp->out_dev */
			if(res && skb != NULL) {
				dev_kfree_skb(skb);
				bond->muic_info.dropped++;
			}			
			read_unlock(&slave->lock);
		} else { /* Add to queue */
			skb_queue_tail(&slave->queues[rp->chan_index], skb);	/* Added to the queue */
			if(atomic_read(&slave->timer_initialized) == 0) { 	/* Timer NOT initialized */
				atomic_set(&slave->timer_initialized, 1);	/* Timer is initialized */
				init_timer(&slave->timer);
				if(slave->tx_complete > jiffies) {
					slave->timer.expires = slave->tx_complete + MUIC_TIME_STEP;

				} else {
					/* Expires almost immediately */
					slave->timer.expires = jiffies + bond->muic_info.min_time_jiffies; 

				}
				add_timer(&slave->timer);
				slave->last_switch = jiffies;		/* Contention starts!!! */
			}
		}
	} else  if (unicast == 0){ /* BROADCAST */
		struct muic_broadcast_entry *bp = NULL;
		struct muic_slave_info *slave;
		struct sk_buff *skb_copy, *extra_skb;
		bond->muic_info.broadcast++; /* Nof packets we broadcast */
		
		for(bp = bond->muic_info.br_head; bp != NULL; bp = bp->next) {
			slave = bp->out_slave->muic_sl_info;
			if(bp->next == NULL) {
				skb_copy = skb;
			} else {
				skb_copy = skb_clone(skb, GFP_ATOMIC);
				if(!skb_copy) {
					printk(KERN_ERR DRV_NAME ": Error bond_muic_xmit(): "
							"skb_clone() failed\n");
					continue;
				}
			}
			
			if(slave->cur_chan == bp->channel && 					/* Listening on current channel */
					atomic_read(&slave->chan_switcher_running) == 0 && 	/* Channel switcher is not running */
					atomic_read(&slave->switch_deferred) == 0) 		/* Switch has not been deferred 
												   If 1 ==> High load on cur channel 
												 ==> don't pump more data directly*/
			{
				/* Card on current channel & Channel switcher is NOT running */
				unsigned long tx_time;

				/* Timer is NOT running, so directly send after locking */
				/* Read lock slave, so switcher won't interfere */
				read_lock(&slave->lock);
				
				if(slave->tx_complete < jiffies){
					slave->tx_start = jiffies;
					slave->relative_tx_complete = 0;
				}
				
				tx_time = FINE_CALC_TRANSMIT_TIME(skb_copy->len);
				slave->total_tx_time += tx_time;
				slave->relative_tx_complete += tx_time;
				slave->tx_complete = slave->tx_start + COARSE(slave->relative_tx_complete);
				
				/* Channel switcher timer is initialized, change mod_timer */
				if(atomic_read(&slave->timer_initialized) == 1) {
					if(slave->tx_complete > slave->timer.expires && 
						(slave->last_switch + bond->muic_info.max_time_jiffies) > slave->tx_complete) {
						/* Increment by step */

						/* Bug Fix: Increment the timer to one time step after the tx completes */
						mod_timer(&slave->timer, (slave->tx_complete + MUIC_TIME_STEP));
						
					}
					else if(slave->tx_complete > slave->timer.expires) { 
						/* Matches when we already hit max time, and tx_complete is beyong expires time */
						/* Bug Fix: Modify timer to expire after tx completes */
						mod_timer(&slave->timer, (slave->tx_complete + MUIC_TIME_STEP));
						atomic_set(&slave->switch_deferred, 1);	/* Only buffer now */
					}
				}
				slave->tx_packets[bp->chan_index]++;
				slave->tx_bytes[bp->chan_index] += skb_copy->len;
				slave->total_tx_packets++;
				slave->total_tx_bytes += skb_copy->len;
				/* Update usage stats */
				bond_muic_calc_add(slave, skb_copy->len);
				res = bond_dev_queue_xmit(bond, skb_copy, slave->dev);	/* slave->dev == bp->out_dev */
				if(res && skb_copy != NULL) {
					dev_kfree_skb(skb_copy);
					bond->muic_info.dropped++;
				}
							
				read_unlock(&slave->lock);
			} else { 
				/* Add to queue */
				/* Broadcast packets given priority over unicast (management packets are broadcasted)
				 * Thus we enqueue broadcst packets at the head of the queue.
				 * This is a hack to give priority to user space process management packets.
				 * TODO: Implement IP header's TOS field based QoS.
				 */
				skb_queue_head(&slave->queues[bp->chan_index], skb_copy);	/* Added to the queue */
				if(atomic_read(&slave->timer_initialized) == 0) { 	/* Timer NOT initialized */
					atomic_set(&slave->timer_initialized, 1);	/* Timer is initialized */
					init_timer(&slave->timer);
					if(slave->tx_complete > jiffies) {
						slave->timer.expires = slave->tx_complete + MUIC_TIME_STEP;

					} else {
						
						slave->timer.expires = jiffies + bond->muic_info.min_time_jiffies; /*Expires almost immediately*/

					}
									
					add_timer(&slave->timer);
					slave->last_switch = jiffies;	/* Contention starts!!! */
				}

			}
		}
	} else { /* DROP the packet! Route not found ???*/
		bond->muic_info.dropped++;
		dev_kfree_skb(skb);
	}

	
	read_unlock(&bond->muic_info.lock);
	read_unlock(&bond->lock);
	return 0;

out:
	if (res && skb != NULL) {
		/* BOND NOT OK, frame not sent */
		dev_kfree_skb(skb);
	}
	
	read_unlock(&bond->muic_info.lock);
	read_unlock(&bond->lock);
	return 0;
}



/*ioctl call ONLY, no one else should use it.*/
/*Caller has Bond lock*/
int bond_muic_route_entry(struct bonding *bond, struct muic_route_entry *entry)
{
	/*Case 1: (Add): Check if there is an entry for 
	 * the given IP address. If NOT -> Add new entry*/

	/*Case 2: (Update): Check if there is an entry for
	 * the given IP address. If YES && entry->out_dev is NOT NULL,
	 * then "Update out_dev to new out_dev and with new dst channel"*/

	/*Case 3: (Remove): Check if there is an entry for
	 * the given IP address. if YES && entry->out_dev is NULL
	 * the "remove the route entry"*/
	
	/*XXX: Since all operations perform some kind of a route operation
	 * without any exception, write lock even before you go in.*/
	
	struct muic_route_entry *new_entry, *tmp;
	static int found;

	write_lock(&bond->muic_info.lock);


	
	/*First Case 3: Otherwise we need to throw up an error*/
	if(entry->out_dev == NULL) {
		d2printk("Trying to find and remove route entry which matches %u.%u.%u.%u\n", 
				NIPQUAD(entry->dip_addr));
		
		found = 0;
		for(tmp = bond->muic_info.head; tmp != NULL && !found; tmp = tmp->next)	{
			d2printk("Route Removal: Checking entry %u.%u.%u.%u --> %s with %u.%u.%u.%u: %s\n", 
				NIPQUAD(tmp->dip_addr), tmp->out_dev->name, 
				 NIPQUAD(entry->dip_addr), (tmp->dip_addr == entry->dip_addr)?"Match":"Mismatch");
			
			if(entry->dip_addr == tmp->dip_addr) {
				found = 1;
				/*Remove the entry*/
				if (tmp == bond->muic_info.head) {//This entry is the head of the list
					if(tmp->next != NULL) {
						bond->muic_info.head = tmp->next;
						bond->muic_info.head->prev = NULL;
					} else {
						bond->muic_info.head = NULL;
					}
					d2printk("Removing the head\n");

				} else {//Not head
					if(tmp->prev != NULL) {
						tmp->prev->next = tmp->next; //Link top entry to bottom entry
					}
					if(tmp->next != NULL) {
						tmp->next->prev = tmp->prev; //Link bottom entry to top entry
					}
				}
				
				d2printk("Removing entry %u.%u.%u.%u --> (%s, %d)\n", 
						NIPQUAD(tmp->dip_addr), tmp->out_dev->name, tmp->dst_chan);
				kfree(tmp);
				goto success;
			}
		}

		if (found == 0) {/*Entry not found*/
			d2printk("(REMOVE) Error: routing entry not found. No action taken\n");
		}
	}
	else {/*entry->out_dev != NULL*/
		found = 0;
		for(tmp = bond->muic_info.head; tmp != NULL && !found; tmp = tmp->next)	{
			if(entry->dip_addr == tmp->dip_addr) {
				int i;
				int chan_found = 0;
				
				found = 1;
				for(i=0; i < entry->out_slave->muic_sl_info->nchan; i++){
					if(entry->out_slave->muic_sl_info->channels[i] == entry->dst_chan){
//						dd2printk("Found channel %d at %d of slave %s\n",
//								entry->dst_chan, i, entry->out_slave->dev->name);
						tmp->chan_index = i;
						chan_found = 1;
						break;
					}
				}

				if(!chan_found) {
					dd2printk("Channel %d not in the list for %s\n", 
							entry->dst_chan, 
							entry->out_slave->dev->name);
					goto err;
				}
				/*Update route with new_outdev*/
				d2printk("Updating route entry for %u.%u.%u.%u from (%s, %d) to (%s, %d)\n",
						NIPQUAD(tmp->dip_addr), tmp->out_dev->name, tmp->dst_chan, 
						entry->out_dev->name, entry->dst_chan);
				tmp->out_dev = entry->out_dev;
				tmp->out_slave = entry->out_slave;
				
				tmp->dst_chan = entry->dst_chan;
				goto success;
			}
		}

		if (found == 0) {/*Entry not found*/
			/*Add a new route entry, to the list*/
			int i;
			int chan_found = 0;
			
			new_entry = (struct muic_route_entry *) kmalloc(sizeof(struct muic_route_entry), GFP_ATOMIC);
			if (new_entry == NULL) {
				printk(KERN_ERR DRV_NAME "Could not allocate memory for new routing entry\n");
				goto err;
			}
			
			/* Find channel in the list */
			for(i=0; i < entry->out_slave->muic_sl_info->nchan; i++){
				if(entry->out_slave->muic_sl_info->channels[i] == entry->dst_chan){
//					dd2printk("Found channel %d at %d of slave %s\n",
				     //						entry->dst_chan, i, entry->out_slave->dev->name);
					new_entry->chan_index = i;
					chan_found = 1;
					break;
				}
			}

			if(!chan_found) {
				dd2printk("Channel %d not in the list for %s\n", entry->dst_chan, entry->out_slave->dev->name);
				kfree(new_entry);
				goto err;
			}

			new_entry->dip_addr = entry->dip_addr;
			new_entry->out_dev = entry->out_dev;
			new_entry->out_slave = entry->out_slave;
			new_entry->dst_chan = entry->dst_chan;	/*XXX: Chan sanity check! (perform in IOCTL call) */
			
			if(bond->muic_info.head == NULL) {
				d2printk("Adding as LIST HEAD, new route entry %u.%u.%u.%u --> (%s, %u)\n",
						NIPQUAD(entry->dip_addr), entry->out_dev->name, entry->dst_chan);
				new_entry->next = new_entry->prev = NULL;	
				bond->muic_info.head = new_entry;
			} else {//Add a new entry at the end of the list
				for(tmp = bond->muic_info.head; tmp->next != NULL; tmp = tmp->next);//Traverse upto the end
				d2printk("Adding new route entry at tail %u.%u.%u.%u --> (%s, %u)\n",
						NIPQUAD(entry->dip_addr), entry->out_dev->name, entry->dst_chan);
				new_entry->next = NULL;
				new_entry->prev = tmp;
				tmp->next = new_entry;
			}
		}

	}
	
success://XXX: Redundant, remove?
	write_unlock(&bond->muic_info.lock);
	return 0;
err:
	write_unlock(&bond->muic_info.lock);
	return -1;	
}

/*ioctl call ONLY, no one else should use it.*/
/*Caller has Bond lock*/
int bond_muic_broadcast_entry(struct bonding *bond, struct muic_broadcast_entry *entry)
{
	/*Case 1: (Add): Check if there is an entry for
	 * the given channel. If NOT -> Add new entry, after
	 * checking the out_dev has this in the valid channels 
	 * list */

	/*Case 2: (Update): Check if there is an entry for
	 * the given channel. If YES && entry->out_dev is NOT NULL,
	 * then "Update out_dev to new out_dev"*/

	/*Case 3: (Remove): Check if there is an entry for
	 * the given channel. if YES && entry->out_dev is NULL
	 * the "remove the route entry"*/
	
	/*XXX: Since all operations perform some kind of a route operation
	 * without any exception, write lock even before you go in.*/
	
	struct muic_broadcast_entry *new_entry, *tmp;
	static int found;

	write_lock(&bond->muic_info.lock);
	
	/*First Case 3: Otherwise we need to throw up an error*/
	if(entry->out_slave == NULL) {
		d2printk("Trying to find and remove route entry which matches %d\n", 
				entry->channel);
		
		found = 0;
		for(tmp = bond->muic_info.br_head; tmp != NULL && !found; tmp = tmp->next)	{
			d2printk("Broadcast entry Removal: Checking entry %d --> %s with %d: %s\n", 
				tmp->channel, tmp->out_slave->dev->name, 
				 entry->channel, (tmp->channel == entry->channel)?"Match":"Mismatch");
			
			if(entry->channel == tmp->channel) {
				found = 1;
				/*Remove the entry*/
				if (tmp == bond->muic_info.br_head) {//This entry is the head of the list
					if(tmp->next != NULL) {
						bond->muic_info.br_head = tmp->next;
						bond->muic_info.br_head->prev = NULL;
					} else {
						bond->muic_info.br_head = NULL;
					}
					d2printk("Removing the head\n");

				} else {//Not head
					if(tmp->prev != NULL) {
						tmp->prev->next = tmp->next; //Link top entry to bottom entry
					}
					if(tmp->next != NULL) {
						tmp->next->prev = tmp->prev; //Link bottom entry to top entry
					}
				}
				
				d2printk("Removing entry %d - %s\n", 
						tmp->channel, tmp->out_slave->dev->name);
				kfree(tmp);
				goto success;
			}
		}

		if (found == 0) {/*Entry not found*/
			d2printk("(REMOVE) Error: broadcast entry not found. No action taken\n");
		}
	}
	else {/*entry->out_dev != NULL*/
		found = 0;
		for(tmp = bond->muic_info.br_head; tmp != NULL && !found; tmp = tmp->next)	{
			if(entry->channel == tmp->channel) {
				int i;
				int chan_found = 0;
				
				found = 1;
				for(i=0; i < entry->out_slave->muic_sl_info->nchan; i++){
					if(entry->out_slave->muic_sl_info->channels[i] == entry->channel){
//						dd2printk("Found channel %d at %d of slave %s\n",
//								entry->channel, i, entry->out_slave->dev->name);
						tmp->chan_index = i;
						chan_found = 1;
						break;
					}
				}

				if(!chan_found) {
					dd2printk("Channel %d not in the list for %s\n", 
							entry->channel, entry->out_slave->dev->name);
					goto err;
				}
				/*Update route with new_outdev*/
				d2printk("Updating broadcast entry for %d from (%s) to %s\n",
						tmp->channel, tmp->out_slave->dev->name, 
						entry->out_slave->dev->name);
				tmp->out_slave = entry->out_slave;
				tmp->channel = entry->channel;
				
				goto success;
			}
		}

		if (found == 0) {/*Entry not found*/
			/*Add a new route entry, to the list*/
			int i;
			int chan_found = 0;
			
			new_entry = (struct muic_broadcast_entry *) kmalloc(sizeof(struct muic_broadcast_entry), GFP_ATOMIC);
			if (new_entry == NULL) {
				printk(KERN_ERR DRV_NAME "Could not allocate memory for new routing entry\n");
				goto err;
			}
			
			/* Find channel in the list */
			for(i=0; i < entry->out_slave->muic_sl_info->nchan; i++){
				if(entry->out_slave->muic_sl_info->channels[i] == entry->channel){
//					dd2printk("Found channel %d at %d of slave %s\n",
//							entry->channel, i, entry->out_slave->dev->name);
					new_entry->chan_index = i;
					chan_found = 1;
					break;
				}
			}

			if(!chan_found) {
				dd2printk("Channel %d not in the list for %s\n", entry->channel, entry->out_slave->dev->name);
				kfree(new_entry);
				goto err;
			}

			new_entry->out_slave = entry->out_slave;
			new_entry->channel = entry->channel;
			
			if(bond->muic_info.br_head == NULL) {
				d2printk("Adding as LIST HEAD, new broadcast entry %d --> %s\n",
						entry->channel, entry->out_slave->dev->name);
				new_entry->next = new_entry->prev = NULL;	
				bond->muic_info.br_head = new_entry;
			} else {//Add a new entry at the end of the list
				for(tmp = bond->muic_info.br_head; tmp->next != NULL; tmp = tmp->next);//Traverse upto the end
				d2printk("Adding new broadcast entry at tail %d --> %s\n",
						entry->channel, entry->out_slave->dev->name);
				new_entry->next = NULL;
				new_entry->prev = tmp;
				tmp->next = new_entry;
			}
		}

	}
	
success://XXX: Redundant, remove?
	write_unlock(&bond->muic_info.lock);
	return 0;
err:
	write_unlock(&bond->muic_info.lock);
	return -1;	
}

/* From net80211/ieee80211.c in madwifi code */
static u_int mhz2ieee(u_int freq) {
	if(freq == 2484)
		return 14;
	if(freq < 2484) /* 2Ghz Band */
		return (freq - 2407) / 5;
	if(freq < 5000) /* 5Ghz Band */
		return 15 + ((freq - 2512) / 20);
	return (freq - 5000) / 5; /* XXX: What's this?*/	
}

int bond_muic_channel(struct bonding *bond, struct muic_req *muic_req){
	struct muic_bond_info *muic = &bond->muic_info;
	int i;
	int channel = muic_req->channel;
	int add = muic_req->add;
	struct muic_slave_info *sl_info = muic_req->sl->muic_sl_info;
	
	if(channel < MUIC_CHAN_MIN || channel > MUIC_CHAN_MAX){
		dd2printk("Channel %d no in range [%d %d]\n", channel, MUIC_CHAN_MIN, MUIC_CHAN_MAX);
		return -1;
	}	
	
	write_lock(&muic->lock);
	if(add != 1){ /* Find channel in the list */
		printk(KERN_INFO DRV_NAME "%s(): can only add channels for now\n", __func__);
		goto err;
	}

	if(add == 1){
		int found = 0, ret;
		struct iw_freq fr_get;
//		dd2printk("Trying to add channel %d to broadcast list\n", channel);
		
		if(sl_info->nchan >= MUIC_MAX_CHANNELS){
			dd2printk("Already dealing with max channels %d, cannot add any more sorry!!!", sl_info->nchan);
			goto err;
		}
		
		for(i=0; i < sl_info->nchan; i++){
			if(sl_info->channels[i] == channel){
				dd2printk("Channel %d already in channel list at position %d, no action taken\n",
						channel, i);
				goto err;
			}
		}
		/* Store channel number and init the queue */
		sl_info->channels[sl_info->nchan] = channel;
		skb_queue_head_init(& sl_info->queues[sl_info->nchan]);
		sl_info->tx_packets[sl_info->nchan] = 0;
		sl_info->tx_bytes[sl_info->nchan] = 0;
		sl_info->avg_qlen[sl_info->nchan] = 0;

		/* Usage info stats - put to zero */
		sl_info->usage_info[sl_info->nchan].usage = 0;
		sl_info->usage_info[sl_info->nchan].cur_usage = 0;
		
		/* Increment nof channels */
		sl_info->nchan++;
//		dd2printk("Added %d to the channel list. Channel list has %d channels now\n", 
//				sl_info->channels[sl_info->nchan-1], sl_info->nchan);
		
		/* Get current channel for the card */
		ret = sl_info->get_iwfreq(sl_info->dev, NULL, (union iwreq_data *) &fr_get, NULL);
		if(fr_get.e)
			sl_info->cur_chan = (__s32) mhz2ieee(fr_get.m / 100000);
		else
			sl_info->cur_chan = (__s32) fr_get.m;

		for(i=0; i < sl_info->nchan; i++) {
			if(sl_info->cur_chan == sl_info->channels[i]){
				found = 1;
				sl_info->cur_chan_index = i;
			}
		}
		if(!found) {
			printk(KERN_ERR DRV_NAME "current channel %d not found in %s channel list\n", 
					sl_info->cur_chan, sl_info->dev->name);
			sl_info->cur_chan_index = -1;	/* Invalid, check in the time out code */
		}
		goto success;
	}

	printk(KERN_INFO DRV_NAME "Control should never reach here\n");

success:
	write_unlock(&muic->lock);
	return 0;
	
err:
	write_unlock(&muic->lock);
	return -1;	
}

/* Caller has bond read lock*/
void bond_muic_dump_route_entries(struct bonding *bond)
{
	struct muic_route_entry *tmp;
	
	read_lock(&bond->muic_info.lock);
	for(tmp = bond->muic_info.head; tmp != NULL; tmp = tmp->next) {
		//printk("%s --> %s\n", mac_sprintf(tmp->dest), tmp->out_dev->name);
		printk("%u.%u.%u.%u --> (%s, %u)\n", 
				NIPQUAD(tmp->dip_addr), tmp->out_dev->name, tmp->dst_chan);
	}
	read_unlock(&bond->muic_info.lock);
	return;
}

/* This is a dummy check. Until we figure out 
 * how to make sure that this is a modified atheros driver running. */
static int check_dev_restrictions(struct bonding *bond, struct slave *slave)
{
	if(!slave || !bond)
		return -1;
	if(!slave->dev->priv)
		return -1;
	
	return 1;
}

int bond_muic_init_slave(struct bonding *bond, struct slave *slave)
{
	struct muic_slave_info *new_sl_info;
	struct muic_bond_info *muic = &bond->muic_info;
	struct iw_freq fr_get;
	u_int cur_chan;
	int ret = 1;

	write_lock(&muic->lock);
	d2printk("%s(): New slave %s\n", __func__, slave->dev->name);
	new_sl_info = (struct muic_slave_info *) kmalloc(sizeof(struct muic_slave_info), GFP_ATOMIC);
	if (new_sl_info == NULL){
		printk(KERN_ERR DRV_NAME "Could not allocate memory for new SLAVE information\n");
		write_unlock(&muic->lock);
		return -1;
	}
	
	/* Get wireless channel get/set handlers */
	new_sl_info->get_iwfreq = get_handler(slave->dev, SIOCGIWFREQ);
	new_sl_info->set_iwfreq = get_handler(slave->dev, SIOCSIWFREQ);

	new_sl_info->get_wireless_stats = slave->dev->get_wireless_stats; /* Will be NULL if not set */

	if(!new_sl_info->get_iwfreq || !new_sl_info->set_iwfreq || !new_sl_info->get_wireless_stats){
		printk(KERN_WARNING DRV_NAME ": %s(): %s does not have %s %s %s handler(s)\n",
				__func__, slave->dev->name,
				new_sl_info->get_iwfreq?"":"SIOCGIWFREQ",
				new_sl_info->set_iwfreq?"":"SIOCSIWFREQ",
				new_sl_info->get_wireless_stats?"":"GET WIRELESS STATS");
		kfree(new_sl_info);
		write_unlock(&muic->lock);
		return -1;
	} else {
		printk(DRV_NAME ": %s(): %s seems like a wireless device. Things seem fine!\n",
				__func__, slave->dev->name);
	}

	if(check_dev_restrictions(bond, slave) < 0) {
		printk(KERN_WARNING DRV_NAME ": %s(): %s FAILED device restrictions check - NOT Atheros?\n", 
				__func__, slave->dev->name);
		kfree(new_sl_info);
		write_unlock(&muic->lock);
		return -1;
	} else {
		printk(DRV_NAME ": %s(): %s passed device restrictions check\n", __func__, slave->dev->name);
	}
	
	new_sl_info->bond = bond;
	new_sl_info->dev = slave->dev;
	new_sl_info->nchan = 0;
	
	/* Switch timer */
	new_sl_info->timer.function = bond_muic_switch_channel;
	new_sl_info->timer.data = (unsigned long) new_sl_info;
	
	/* Stats timer */
	new_sl_info->stats_timer.function = bond_muic_update_stats;
	new_sl_info->stats_timer.data = (unsigned long) new_sl_info;

	/* Init, set expire time and add timer */
	init_timer(&new_sl_info->stats_timer);
	new_sl_info->stats_timer.expires = jiffies + UPDATE_STATS_TIME;
	add_timer(&new_sl_info->stats_timer);

	
	ret = new_sl_info->get_iwfreq(slave->dev, NULL, (union iwreq_data *) &fr_get, NULL);
	if(fr_get.e)
		cur_chan = mhz2ieee(fr_get.m / 100000);
	else
		cur_chan = fr_get.m;
			
	new_sl_info->cur_chan = (__s32) cur_chan;
	d2printk("%s: current channel: %d\n", new_sl_info->dev->name, new_sl_info->cur_chan);
	atomic_set(&(new_sl_info->timer_initialized), 0);
	atomic_set(&(new_sl_info->chan_switcher_running), 0);
	atomic_set(&(new_sl_info->switch_deferred), 0);
	new_sl_info->switch_defer_count = 0;
	new_sl_info->total_deferrals = 0;
	new_sl_info->exit_q_empty = 0;
	new_sl_info->exit_t_max = 0;
	new_sl_info->total_tx_packets = 0;
	new_sl_info->total_tx_bytes = 0;
	new_sl_info->tx_complete = jiffies;
	new_sl_info->tx_start = jiffies;
	new_sl_info->relative_tx_complete = 0;
	new_sl_info->switches = 0;
	new_sl_info->average_tx_complete = 0;
	new_sl_info->average_time_on_channel = 0;
	new_sl_info->average_packets_per_switch = 0;
	new_sl_info->average_rate = 0;
	new_sl_info->packets_last_switch = 0;
	new_sl_info->total_tx_time = 0;
	slave->muic_sl_info = new_sl_info;
	write_unlock(&muic->lock);
	return 0;
}

/* Caller must hold bond lock for write */
void bond_muic_deinit_slave(struct bonding *bond, struct slave *slave)
{
	struct muic_route_entry *tmp;
	struct muic_broadcast_entry *bp;
	
	d2printk("Remove all route entries with Outdev: %s\n", slave->dev->name);
	/*Traverse the route_list & remove all entries with out_dev = slave->dev*/

	write_lock(&bond->muic_info.lock);
	for(tmp = bond->muic_info.head; tmp != NULL; tmp = tmp->next) {
		if(tmp->out_dev == slave->dev) {/*Remove from route table*/
				/*Now remove the entry*/
			if (tmp == bond->muic_info.head) {//Remove head
				if(tmp->next != NULL) {
					bond->muic_info.head = tmp->next;
					bond->muic_info.head->prev = NULL;
				} else {
					bond->muic_info.head = NULL;
				}
				d2printk("Removing the head\n");
			} else {//Not head
				if(tmp->prev != NULL) {
					tmp->prev->next = tmp->next; //Link top entry to bottom entry
				}
				if(tmp->next != NULL) {
					tmp->next->prev = tmp->prev; //Link bottom entry to top entry
				}
			}
			d2printk("Removing entry %u.%u.%u.%u --> (%s, %u)\n", 
					NIPQUAD(tmp->dip_addr), tmp->out_dev->name, tmp->dst_chan);
			kfree(tmp);
		}
	}
	
	for(bp = bond->muic_info.br_head; bp != NULL; bp = bp->next) {
		if(bp->out_slave->dev == slave->dev) {/*Remove from route table*/
				/*Now remove the entry*/
			if (bp == bond->muic_info.br_head) {//Remove head
				if(bp->next != NULL) {
					bond->muic_info.br_head = bp->next;
					bond->muic_info.br_head->prev = NULL;
				} else {
					bond->muic_info.br_head = NULL;
				}
				d2printk("Removing the head\n");
			} else {//Not head
				if(bp->prev != NULL) {
					bp->prev->next = bp->next; //Link top entry to bottom entry
				}
				if(bp->next != NULL) {
					bp->next->prev = bp->prev; //Link bottom entry to top entry
				}
			}
			d2printk("Removing entry %d --> %s\n", 
					bp->channel, bp->out_slave->dev->name);
			kfree(bp);
		}
	}


	if(slave->muic_sl_info->nchan > 0) {
		int i;
		for(i=0; i < slave->muic_sl_info->nchan; i++){
			if(skb_queue_len(&slave->muic_sl_info->queues[i]) > 0) {
				printk("%s: channel %d queue, purging %u packets\n", 
						slave->dev->name, slave->muic_sl_info->channels[i], 
						skb_queue_len(&slave->muic_sl_info->queues[i]));
			}
			skb_queue_purge(&slave->muic_sl_info->queues[i]);
		}
	}

	if(atomic_read(&slave->muic_sl_info->timer_initialized) == 1) {
		printk("Timer seems to be initialized\n");
		printk("Timer is %s\n", timer_pending(&slave->muic_sl_info->timer)?"init":"NOT init");
		if(slave->muic_sl_info->timer.expires > jiffies) {
			del_timer_sync(&slave->muic_sl_info->timer);
		} else {
			printk(" Buf expires %lu is <= %lu jiffies\n",
					slave->muic_sl_info->timer.expires, jiffies);
		}
	}

	printk("Disable stats timer\n");
	del_timer_sync(&slave->muic_sl_info->stats_timer);

	kfree(slave->muic_sl_info);
	write_unlock(&bond->muic_info.lock);
	
	return;
}

int
bond_muic_return_stats(struct muic_slave_info *slave, struct muic_stats_u_response *response)
{
	int i;

	if(!slave || !response) {
		return -1;
	}
	
	read_lock(&slave->lock);
	/* Channels serviced */
	response->nchan = slave->nchan;
	for(i=0; i < slave->nchan; i++) {
		response->channel[i] = (int) slave->channels[i];
		/* convert to milli seconds - scale with (1000 / MY_HZ ) */
		response->usage[i] = (unsigned int) (slave->usage_info[i].usage  * 1000 / MY_HZ);
	}
	read_unlock(&slave->lock);

	return 0;
}

/* XXX:Should BOND MUIC INFO be locked? I guess so, add this in later - CHECK IOCTL  */
int 
bond_muic_explicit_switch_channel(struct muic_slave_info *slave, s32 channel)
{
	int i, found = 0, chan_index = -1, ret;
	struct iw_freq fr_set;
	
	read_lock(&slave->lock);
#if 0
	if(slave->cur_chan == channel) {
		printk("No action required, cur_chan %d same as chan request %d\n",
				slave->cur_chan, channel);
		return -1;
	}
#endif	
	for(i=0; i < slave->nchan; i++) {
		if(slave->channels[i] == channel) {
			found = 1;
			chan_index = i;
		}
	}
	
	if(!found) {
		printk(KERN_ERR DRV_NAME "Channel %d not in the %s valid channel list\n",
				channel, slave->dev->name);
		return -1;
	}
	read_unlock(&slave->lock);

	/* Acquire write lock, modifying data structures */
	write_lock(&slave->lock);

	if(atomic_read(&slave->timer_initialized) == 1) {
		printk("Timer seems to be initialized\n");
		printk("Timer is %s\n", timer_pending(&slave->timer)?"init":"NOT init");
		if(slave->timer.expires > jiffies) {
			del_timer_sync(&slave->timer);
		} else {
			printk(" Buf expires %lu is <= %lu jiffies\n",
					slave->timer.expires, jiffies);
		}
	}
	
	for(i=0; i < slave->nchan; i++) {
		if(slave->channels[i] == channel)
			continue;
		/* Purge all buffered packets */
		if(skb_queue_len(&slave->queues[i]) > 0) {
			printk("%s: channel %d queue, purging %u packets\n", 
				slave->dev->name, slave->channels[i], 
				skb_queue_len(&slave->queues[i]));
		}
		/* Does it matter if the queue is NOT empty, we can still call purge */
		skb_queue_purge(&slave->queues[i]);
	}
	/* Switch the channel now */
	fr_set.m = (__s32) slave->channels[chan_index];
	fr_set.e = 0;
	ret = slave->set_iwfreq(slave->dev, NULL, (union iwreq_data *) &fr_set, NULL);
	
	/* Set cur chan */
	slave->cur_chan = slave->channels[chan_index];
	slave->cur_chan_index = chan_index;

	/* Add switch penality to this channel */
	bond_muic_add_time(slave, (SWITCH_PENALITY * 10 / 1000));

	write_unlock(&slave->lock);

	return 0;
}

void bond_muic_empty_route_table(struct bonding *bond)
{
	struct muic_route_entry *node1, *node2;
	write_lock(&bond->muic_info.lock);
	for(node1 = bond->muic_info.head; node1 != NULL;) {
		node2 = node1->next;
		d2printk("Removing entry %u.%u.%u.%u --> (%s, %u)\n", 
				NIPQUAD(node1->dip_addr), node1->out_dev->name, node1->dst_chan);
		kfree(node1);
		node1 = node2;
	}
	bond->muic_info.head = NULL;
	write_lock(&bond->muic_info.lock);

	return;
}

#define CCK_PROC_FS
#ifdef CCK_PROC_FS
#ifdef CONFIG_PROC_FS
#define MUIC_PROC_FILE_NAME "muic_info"

#define SEQ_START_TOKEN ((void *)1)

extern struct proc_dir_entry *bond_proc_dir;	/*Move this to GLOBALS*/

static void *bond_muic_info_seq_start(struct seq_file *seq, loff_t *pos)
{
	struct bonding *bond = seq->private;
	struct muic_route_entry *rentry;
	loff_t off = 0;
	//struct slave *slave;
	//int i;

	/* make sure the bond won't be taken away */
        read_lock(&dev_base_lock);
        read_lock_bh(&bond->lock);
	read_lock(&bond->muic_info.lock);

        if (*pos == 0) {
                return SEQ_START_TOKEN;
        }

	for(rentry = bond->muic_info.head; rentry != NULL; rentry = rentry->next) {
		if(++off == *pos) {
			return rentry;
		}
	}
	

        return NULL;
}
        
static void bond_muic_info_seq_stop(struct seq_file *seq, void *v)
{
	struct bonding *bond = seq->private;
	read_unlock(&bond->muic_info.lock);
	read_unlock_bh(&bond->lock);
	read_unlock(&dev_base_lock);
}

static void *bond_muic_info_seq_next(struct seq_file *seq, void *v, loff_t *pos)
{
	struct bonding *bond = seq->private;
	struct muic_route_entry *rentry = v;

	++*pos;
	if (v == SEQ_START_TOKEN) {
		return bond->muic_info.head;
	}


	if(rentry != NULL){
		rentry = rentry->next;
		return rentry;
	}
	
	return NULL;
}
static void bond_muic_pretty_print_rentry(struct seq_file *seq, const struct muic_route_entry *rentry)
{
	struct bonding *bond = seq->private;
	
/* Perhaps you can do a lot of sanity checking right here */
	if(rentry == SEQ_START_TOKEN){
		struct slave *slave;
		int i;
		struct muic_broadcast_entry *bp;
		seq_printf(seq, "\nTotal broadcast packets %u. Dropped packets %u\n",
				bond->muic_info.broadcast, bond->muic_info.dropped);
		bond_for_each_slave(bond, slave, i) {
			struct muic_slave_info *muic_slave_info = slave->muic_sl_info;
			int j;
			seq_printf(seq, "\nSlave %s\n\n", muic_slave_info->dev->name);
			seq_printf(seq, "%lu Total packets %lu Total bytes\n",
					muic_slave_info->total_tx_packets,
					muic_slave_info->total_tx_bytes);
			seq_printf(seq, "Timer %d %s and switcher %d %s\n",
					atomic_read(&muic_slave_info->timer_initialized),
					atomic_read(&muic_slave_info->timer_initialized)?"init":"NOT init",
					atomic_read(&muic_slave_info->chan_switcher_running),
					atomic_read(&muic_slave_info->chan_switcher_running)?"running":"sleeping");
			seq_printf(seq, "Timer expires %lu, last switch %lu, jiffies %lu\n",
					muic_slave_info->timer.expires, muic_slave_info->last_switch, jiffies);
			seq_printf(seq, "Current channel %d\nTotal channels %d\n", 
					muic_slave_info->cur_chan,
					muic_slave_info->nchan);
			seq_printf(seq, "Switched channel %u times. Avg tx complete %lu. Avg time on channel %lu.\n" 
					"Avg packets per switch %lu. Avg rate %lu\n"
					"Total calc. tx time %lu. Total switch deferrals %u\n",
					muic_slave_info->switches,
					muic_slave_info->average_tx_complete,
					muic_slave_info->average_time_on_channel,
					muic_slave_info->average_packets_per_switch,
					muic_slave_info->average_rate,
					muic_slave_info->total_tx_time,
					muic_slave_info->total_deferrals);
			seq_printf(seq, "(Exit Q empty %u) (Exit max time %u)\n",
					muic_slave_info->exit_q_empty, muic_slave_info->exit_t_max);
			for(j=0; j < muic_slave_info->nchan; j++) {
				seq_printf(seq, "Chan %d - %u packets %u bytes %u pkts backlog"
						" %lu usage (us) %lu cur-usage(us) %u average queue length\n", 
						muic_slave_info->channels[j],
						muic_slave_info->tx_packets[j],
						muic_slave_info->tx_bytes[j],
						skb_queue_len(&muic_slave_info->queues[j]),
						muic_slave_info->usage_info[j].usage,
						muic_slave_info->usage_info[j].cur_usage,
						muic_slave_info->avg_qlen[j]);
			}
		}
		seq_printf(seq, "\nBroadcast list\n");
		for(bp = bond->muic_info.br_head; bp != NULL; bp = bp->next){
			seq_printf(seq, "%d - %s\n", bp->channel, bp->out_slave->dev->name);
		}
		seq_printf(seq, "\nRouting Table\n");
	} else {
		seq_printf(seq, "%u.%u.%u.%u \t (%s, %d)\n",  
				NIPQUAD(rentry->dip_addr), 
				rentry->out_dev->name, 
				rentry->dst_chan);
	}
}
static int bond_muic_info_seq_show(struct seq_file *seq, void *v)
{
	if (v == SEQ_START_TOKEN){
		seq_printf(seq, "%s\n", "MUIC: Version 0.0.1");
		bond_muic_pretty_print_rentry(seq, v);
	} else {
		bond_muic_pretty_print_rentry(seq, v);
	}

	return 0;
}

static struct seq_operations bond_muic_info_seq_ops = {
	.start = bond_muic_info_seq_start,
	.next  = bond_muic_info_seq_next,
	.stop  = bond_muic_info_seq_stop,
	.show  = bond_muic_info_seq_show,
};

static int bond_muic_info_open(struct inode *inode, struct file *file)
{
	struct seq_file *seq;
	struct proc_dir_entry *proc;
	int res;
	res = seq_open(file, &bond_muic_info_seq_ops);
        if (!res) {
                /* recover the pointer buried in proc_dir_entry data */
                seq = file->private_data;
                proc = PDE(inode);
                seq->private = proc->data;
        }

        return res;
}

static struct file_operations bond_muic_info_fops = {
	.owner   = THIS_MODULE,
	.open    = bond_muic_info_open,
	.read    = seq_read,
	.llseek  = seq_lseek,
	.release = seq_release,
};

//XXX: Locking requirements???!!! 
//Does caller have lock (to be called from muic_initialize) 
//bond_main routines don't lock,...
//perhaps cause they haven't yet initialized the driver?
//
static int bond_muic_create_proc_entry(struct bonding *bond)
{
	if (bond_proc_dir) {
		bond->muic_info.proc_entry = create_proc_entry(MUIC_PROC_FILE_NAME,
							S_IRUGO,
							bond_proc_dir);
		if (bond->muic_info.proc_entry == NULL) {
			printk(KERN_WARNING DRV_NAME
			       ": Warning: Cannot create /proc/net/%s/%s\n",
			       DRV_NAME, MUIC_PROC_FILE_NAME);
		} else {
			bond->muic_info.proc_entry->data = bond;
			bond->muic_info.proc_entry->proc_fops = &bond_muic_info_fops;
			bond->muic_info.proc_entry->owner = THIS_MODULE;
			//memcpy(bond->proc_file_name, bond_dev->name, IFNAMSIZ);
		}
	}
	return 0;
}

//XXX: Locking requirements???!!!
//To be called from muic_deinitialize
static void bond_muic_remove_proc_entry(struct bonding *bond)
{
        if (bond_proc_dir && bond->muic_info.proc_entry) {
		remove_proc_entry(MUIC_PROC_FILE_NAME, bond_proc_dir);
		bond->muic_info.proc_entry = NULL;
	}
}

#endif /* CONFIG_PROC_FS*/
#endif /* CCK_PROC_FS */

int bond_muic_initialize(struct bonding *bond)
{
	rwlock_init(&bond->muic_info.lock);
	write_lock(&bond->muic_info.lock);
	bond->muic_info.head = NULL;
	bond->muic_info.br_head = NULL;
	bond->muic_info.dropped = 0;
	bond->muic_info.broadcast = 0;

	if(bond->params.muic_time_min) {
		/* Convert to jiffies using HZ, input value expected in milli seconds */
		bond->muic_info.min_time_jiffies = (unsigned long) (bond->params.muic_time_min * HZ) / 1000;
	} else {
		bond->muic_info.min_time_jiffies = MUIC_TIME_MIN;	/* Already in jiffies */ 
	}
	
	if(bond->params.muic_time_max) {
		/* Convert to jiffies using HZ, input value expected in milli seconds */
		bond->muic_info.max_time_jiffies = (unsigned long) (bond->params.muic_time_max * HZ) / 1000;
	} else {
		bond->muic_info.max_time_jiffies = MUIC_TIME_MAX;	/* Already in jiffies */ 
	}

	printk(KERN_INFO "MUIC Parameters in jiffies (Min - %lu) (Max - %lu)\n", 
			bond->muic_info.min_time_jiffies, bond->muic_info.max_time_jiffies);
#ifdef CCK_PROC_FS
#ifdef CONFIG_PROC_FS
	bond_muic_create_proc_entry(bond);
#endif /* CONFIG_PROC_FS*/
#endif /* CCK_PROC_FS */
	write_unlock(&bond->muic_info.lock);
	dd2printk("Initialized\n");
	return 0;
}

void bond_muic_deinitialize(struct bonding *bond)
{
	d2printk("Trying to de-initialize MUIC de-initialized\n");
	bond_muic_empty_route_table(bond);
#ifdef CCK_PROC_FS
#ifdef CONFIG_PROC_FS
	bond_muic_remove_proc_entry(bond);
#endif /* CONFIG_PROC_FS*/
#endif /* CCK_PROC_FS */
	dd2printk("De-init successful\n");
	return;
}
